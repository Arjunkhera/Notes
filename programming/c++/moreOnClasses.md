## More on Classes


### Initialiser Lists
The order of initialisation is same as the order of declaration


**Inspector**
1. Functions that cannot change the state of the object
2. Simply put a const in front of the function signature

**Mutator**
Functions that can change the state of the object

**Mutable members**
Mutable members are explicitly allowed to be changed, even inside Inspector functions

**Const Objects**
const objects marks all methods const, so it can only access inspector, that is those 
which does not affect the state


### Callbacks

1. Use function pointers. With functions, using & is optional. But it cannot capture the state
2. Or we can user Interfaces also, declaring virtual functions
3. We can also use templates

A class in which the paranthesis are overloaded is known as **Functor** or **Function Object**

In callback, any problems can be solved by adaptors(wrappers) or aka **Functors**

**Capture**
1. Whatever we provide to the functor
2. Execute by capture constructor

**Smarty pants in town**
1. smartPointers
2. smartArrays
3. Functors

**auto**
compile type inference

### Lambda expression

1. Nothing, but syntax sugar to create functors
2. Capture constructor arguments can be put in the subscript operator
3. In java,csharp the whole context is captured
4. but for c++, we need to tell what is to be captured

- Lambda's generated by the compiler are inspectors
- We can make it mutable by using the mutable keyword 

### Closure

1. The concept where local context is to be remembered till the callback


---

### Function keyword

It provides the signature of the method that has to be subscribed

```c++

#include<iostream>
#include<future>

using namespace std;

void DoVendorJob(std::function<void(int,int)> obj){
    cout<<"Start vendor job \n";
    obj(100,200);
    cout<<"Stop vendor job \n";
}

void ClientFun(int x,int y){
    cout<<"client fun x = "<<x<<" and y = "<<y<<endl;
}

class Functor{
    public:
        void operator()(int x,int y){
            cout<<"functor x = "<<x<<" and y = "<<y<<endl;
        }
};

int  main(){

    Functor obj;

    DoVendorJob(ClientFun);
    DoVendorJob(obj);
    DoVendorJob([](int x,int y) { cout<<"lambda fun x = "<<x<<" and y = "<<y<<endl; });

    return 0;
}

```

### How to adapt to signature differences between our functions and those of the vendor

1. We can enclose our function in a lambda according to our signature
2. However, the outer lambda parameters will be similar to the vendor
3. Which means while the passed lamda matches the vendor
4. The inner function call is the one which we want

```c++
#include<iostream>
#include<future>

using namespace std;

void DoVendorJob(std::function<void(int)> obj){
    cout<<"Start vendor job \n";
    obj(100);
    cout<<"Stop vendor job \n";
}

void ClientFun(int x,int y){
    cout<<"client fun x = "<<x<<" and y = "<<y<<endl;
}

int  main(){

using FPTR = void(*)(int,int);
FPTR fp = &ClientFun;
int par = 200;

auto fnc = [=](int val){
    fp(val,par);
};

DoVendorJob(fnc);

return 0;
}
```

**Or we can simply use std::bind**
- So, in bind here we tell that _1 is going to be provided later and here is the value that we want to pass
- Overall, it does exactly the same thing that we did in the above code using functors


```c++
int  main(){

    std::function<void(int)> fnc = std::bind(&ClientFun, _1, 200);
    DoVendorJob(fnc);

    return 0;
}
```

### Currying

Binding and changing parameters according to our needs using bind

```c++

double div1(double x,double y){
	return x/y;
}

int  main(){

    std::function<double(double,double)> Inv = std::bind(&div1, _2, _1);
    cout<<" Inv of 1/4 = "<< Inv(1, 4) << endl;

    std::function<double(double)> divBy5 = std::bind(&div1, _1, 5);
    cout<<" Inv of 1/5 = "<< divBy5(1) << endl;
    
    return 0;
}
```

### Type Inference

1. Auto works at compile time
2. If we want the type inference to depened on an expression, we use **decltype**
3. The variable is assigned the type equivalent to the expression 
4. And then truncated the value on rhs of = to this type

```c++
int  main(){

    auto x = 100;
    auto y = 12.3;
    auto z = 1.03f;

    cout<<"x = "<<x<< " type = "<< typeid(x).name()<<endl;
    cout<<"y = "<<y<< " type = "<< typeid(y).name()<<endl;
    cout<<"z = "<<z<< " type = "<< typeid(z).name()<<endl;
    cout<<"---------------"<<endl;

    auto a = y+z;
    auto b = x+y;
    cout<<"a = "<<a<< " type = "<< typeid(a).name()<<endl;
    cout<<"b = "<<b<< " type = "<< typeid(b).name()<<endl;
    
    decltype(x*2+y+5) c = x+y;
    cout<<"c = "<<c<< " type = "<< typeid(c).name()<<endl;
    
    return 0;
}

```

1. Here is a good example
2. We cast the function return type to depend on what was passed as template
3. This gives us freedom to set return type according to our own requirement
4. The second string argument in static_assert is optional from c++17 onwards 

```c++
// modern c++
auto fun1(int x,int y)->double
{
    return x*1.0 + y*1.0;
}

auto fun1(int x,int y)->decltype(fun1(1,2))
{
    return x*1.0 + y*1.0;
}

template<typename T1, typename T2>
auto fun3(T1 x, T2 y)-> decltype(x+y)
{
    return x+y;
}

//c++11
static_assert(std::is_same<int, decltype(fun3(10,20))>(),"Yes,Matches");
// static_assert(std::is_same<int, decltype(fun3(10,20))>(),"No,does not matche");

```

1. Now why do we even need to specify the return type
2. C++14 introduced **auto type deduce**
3. So we no longer need to specify the return type

```c++
template<typename T1, typename T2>
auto fun4(T1 x, T2 y)
{
	return x+y
}
```

1. Though we have to make sure that all the return types are same

```c++
auto fun5(int par){
    if(10 == par)
        return 3.45;
    // never enclose the return in a else block
    // huge performance loss
    return 4.56;
    // cannot provide two different types of return types
    // return 4;
}
```

### Higher order Functions

1. Recieve functions or return functions
2. Here we see an example of currying and lambdas

```c++
#include<iostream>
#include<string>

using namespace std;

auto Greet(string msg){
    return [msg](string seperator){
        return [msg,seperator](string name){
            cout<<msg<<seperator<<name<<endl;
        };
    };
}

int main(){

    Greet("Welcome")("*****")("Name");

    // currying : to curry means already set, cooked
    auto sepFun = Greet("hello");
    sepFun("---")("Arjun");
    sepFun("^^^")("Khera");

    auto nameFun = sepFun("--->");
    nameFun("Sachin");
    nameFun("Batman");

    return 0;
}

```

### Making functions compile timed

1. Put a const expression in front of function
2. So, while templates are expanded at compile time, this function is also available at compile time


```c++
#include<iostream>
#include<string>

using namespace std;

/*
// this will give error
// as return type is given at runtime
int fun(int par){
    if(10 == par){
        return 5;
    }

    return 10;
}
*/

// so we do this
constexpr int fun(int par){
    if(10 == par){
        return 5;
    }

    return 10;
}

template<typename T,int Size>
class Stack{
    T arr[Size];

    public:

};

int main(){

    Stack<int, 4> stk1;
    Stack<int, fun(10)> stk2;

    int arr[5];
    int arr1[fun(2)];

    return 0;
}
```

### User Defined Literals

1. Dont do this for a variable
2. Only for constants 
3. They can be of many types
4. For examples, string literals can work on some special string requirements
5. Lots of third party libraries make use of them
6. The empty string is the syntax for informing the compiler, hey this is a literal

```c++
#include<iostream>
#include<string>

using namespace std;

long double operator "" _rad(long double deg){
    return 3.14159/180.0 *deg;
}

int main(){

    auto angle = 90.0_rad;

    return 0;
}

```

### Enums

1. Enum values should always be unique
2. You cannot have the same value in two different enums
3. So now we have scoped enums since c++11
4. Also, now we can have forward enum declarations
5. And, enums are also typed

```c++
#include<iostream>
#include<string>

using namespace std;

// enums can also by typed
// forward declaration of enums for modern c++
enum class CollegeSignal:char;

// scoped enums for modern c++
enum class TrafficSignal:char{
    red,
    green,
    yellow
};

enum class CollegeSignal{
    slipper,
    wave,
    smile
};

int main(){

    TrafficSignal signal = TrafficSignal::red;

    switch(signal){
        case TrafficSignal::red:
            cout<<"red";

    }

    return 0;
}
```

### Rvalue objects

1. When we want to return objects
2. That return is supposed to be sent after a function gets over
3. Hence we store temporarily in rvalue objects

```c++
#include<iostream>
#include<string>

using namespace std;

class CA{
    int *i;

    public:
        CA():i(new int(100)){
            cout<<"CA default"<<endl;
        }
        CA(const CA &par) :i(new int(*par.i)){
            cout<<"CA Copy"<<endl;
        }
        ~CA(){
            cout<<"DTor releasing i="<<i<<endl;
        }
        void fun(){
            cout<<"Hello"<<endl;
        }
};

CA CA_Factory(){
    CA temp;
    // do something
    return temp;
}


int main(){

    CA obj = CA_Factory();
    obj.fun(); 
    return 0;
}

```
---

Type of casting in C++

1. const_cast
2. reinterpret
3. static
4. dynamic

---

### Ownership transfer and meeting with RValue Reference

1. To reference the rvalue, we use double &
2. We need to do ownership transper to prevent temp from releasing memory
3. But we want the deep copy to actually happen in the main  
4. So we use something know as **move constructor**
5. It modifies the rvalue

```c++
#include<iostream>
#include<string>

using namespace std;

class CA{
    int *i;

    public:
        CA():i(new int(100)){
            cout<<"CA default"<<endl;
        }
        CA(CA &&par) :i(par.i){

            // move constructor
            // using for rvalue object
            par.i = NULL;
            cout<<"CA Copy"<<endl;
        }
        ~CA(){
            cout<<"DTor releasing i="<<i<<endl;
        }
        void fun(){
            cout<<"Hello"<<endl;
        }
};

CA CA_Factory(){
    CA temp;
    // do something
    return temp;
}


int main(){

    CA obj = CA_Factory();
    obj.fun(); 
    return 0;
}

```

---

### Packing, Unpacking and hands on with Variadic Template

1. We can use packing and unpacking to make do with variable number of parameters

```c++

#include<iostream>

using namespace std;

// without pack
/*
template<typename T>
void PrintMe(T val){
    cout<<val<<endl;
}

void easy(){
    
    PrintMe("Sachin");
    PrintMe(100);
    PrintMe(3.1415);
    PrintMe('c');
    PrintMe(100);
    PrintMe(200);
    PrintMe('e');
    PrintMe("Hill");

}

*/

// with pack
// but dont know where to stop
/*
template<typename F,typename ...T>
void PrintMe(F val,T ...pck)
{
    cout<<val<<"\t";
    PrintMe(pck...);
}
*/

// so we create a specialised version
void PrintMe(){
    cout<<endl;
}

// and the packing and unpacking remains the same
template<typename F,typename ...T>
void PrintMe(F val,T ...pck)
{
    cout<<val<<"\t";
    // pack again
    PrintMe(pck...);
}


int main(){
    PrintMe("Sachin",100,3.1415,'c');
    
    return 0;
}

```


### Forward constructors


```c++
#include<iostream>

using namespace std;

class CA{
    public:
        CA(){
            cout<<"CA default"<<endl;
        }
        CA(const CA& par){
            cout<<"CA Deep copy "<<endl;
        }

        CA(CA &&par){
            cout<<"CA Move"<<endl;
        }
        ~CA(){
            cout<<"CA DTor"<<endl;
        }
};

class CB{
    public:
        CB(){
            cout<<"CB default"<<endl;
        }
        CB(int val){
            cout<<"CB(int)"<<endl;
        }
        CB(int x,int y){
            cout<<"CB(int,int)"<<endl;
        }
        CB(CA objCa){
            cout<<"CB(CA)"<<endl;
        }
        ~CB(){
            cout<<"CB DTor"<<endl;
        }
};

class Wrapper{
    CB objCb;

    public:

    Wrapper():objCb(){

    }
    Wrapper(int par):objCb(par){

    }
    Wrapper(int par1,int par2):objCb(par1,par2){

    }
    // Wrapper(CA caPar):objCb(caPar){

    // }
    // using move creates on less object
    Wrapper(CA caPar):objCb(std::move(caPar)){

    }
};

class betterWrapper{
    CB objCb;
    
    public:
        // forward constructor
        template<typename ...T>
        betterWrapper(T ...pck):objCb(pck ...){

        }

        // perfect forward constructor : introduced in c++11
        template<typename ...T>
        betterWrapper(T ...pck):objCb(std::forward<T>(pck) ...){

        }
}

int main(){

    CA caObj;
    Wrapper w1;
    Wrapper w2(100);
    Wrapper w3(100,200);
    cout<<"------------"<<endl;
    Wrapper w4(caObj);
    cout<<"------------"<<endl;
 
    return 0;
}

```

### Types of Constructors

1. Default
2. Copy
3. One Param
4. Expilicit
5. Multiparam
6. Move
7. Forward
8. Perfect forward
9. Init



