# Everything

- A single java file can contain more than one class
- We can make immutable objects, fancy way of saying values are final and cannot be changed once assigned. A good example is String class from java.lang
- Use of toString for classes can lead to stack overflow if their is circular reference. Be carefu about using classes in toString or remove toString from one of the classes being referenced.

## Constants

- Java uses the final keyword
- Uninitialised final variables cannot be used for printing. They need to be initialised first
- Unlike C++, you can declare first, and initialise later. But you can only initialise once 

## Access Modifiers

**Class**

- Public : accessible by any class, same package or not
- Package Private(default, no explicit modifier) : visible only to classes in the same package
 
 
**Fields and Methods**

| Modifier  | Class | Package | SubClass | Global |
|-----------|-------|---------|----------|--------|
| Public    | Yes   | Yes     | Yes      | Yes    |
| Protected | Yes   | Yes     | Yes      | No     |
| Default   | Yes   | Yes     | No       | No     |
| Private   | Yes   | No      | No       | No     |


## Inheritance

- If you do not want a class to be inherited, use the final keyword
- Standard classes such as Integer, Long, String cannot be extended
- Superclass aka base, parent
- Subclass aka child, extended, derived
- Note, if you declare a parameterised constructor, then java does not provide a default constructor. Hence don't forget to declare a default constructor in parent alongside if you intent to use in the child class

## Overriding 

- The method must have the same name as in the superclass
- The arguments should be exactly the same as in the superclass method
- The return type should be the same type or a subtype of the return type declared in the method of the superclass
- The access level must be the same or more open than the overridden method's access level
- A private method cannot be overridden because it's not inherited by subclasses
- If the superclass and its subclass are in the same package, then package-private methods can be overridden
- Static methods cannot be overridden
- To prevent overriding, either use static or final
- the signature of static method and other methods in parent and child classes should never match
- do read this [stack overflow answer](https://stackoverflow.com/a/12818082/5131614)
- the return type for overriding can only differ when the return type of base is either same or a derived class of the base

## SuperClass Reference

- You can cast a super class to a sub class only in the scenario where th object initially created was of the sub class.
When to use super class reference 
1. Processing an array (or another collection) of objects which have different types from the same hierarchy
2. A method that accepts an object of the base class, but can also work with objects of its subclasses



## Packages

- Best practise is to start in small case for naming packages
- Package and import statements are optional
- In order to use static imports, write static after import
- In order to import all files in a package, use import package.path.*
- Avoid importing all files until unless required
- You can directly invoke static classes and memebers of a class using without any prefix by using * in front of import name


**Default Package**
- If you do not provide any package name for your file, it is put in the default package
- The default package classes cannot be imported in other packages, thus making it extremely disadvantageous


## Constructors

- Default constructor is automatically generated by the compiler
- However, if you provide an instance of any type of constructor. The default constructor will not be generated
- If you call another constructor from a constructor, the call should be the first line of execution in the body of the calling constructor

## Annotations

- Java has only three built in general purpose annotations
    - @Deprecated
    - @SupressWarnings
    - @Override
- Some annotations require you to specify default values

## Initialisation Blocks

- Always executed before the constructor
- Static initialisation blocks can only access the static fields and methods
- They are after field initliasation
- Order of execution of blocks is according to the order in which they are written
- Static initialisation blocks are always executed before any other execution blocks
- Static initialisation block is only invoked once, whenever the first object created using new

## Super

- Can be used to access fields, methods or constructors of parent class
- Invoking super should be the first line in base class constructor 
- In case of default constructor, java automatically invokes the parent class constructor
  
  
## Polymorphism

Broadly classified as either of the two forms
1. Static(Compile Time) : achieved using method overloading 
2. Dynamic(Run Time) : achieved using method overriding 

Other Theoretical definitions include
1. Ad Hoc Polymorphism : same as method overloading
2. Subtype Polymorphism aka subtyping : possibility to use an instance of the subclass when an instance of the base is permitted
3. Parametric Polymorphism : same as generic programming

In runtime polymorphism(subtyping/overriding) the result of a method call depends on the actual type of the instance, not the reference type
  

## The Object class

- The object class is the parent of any class in java by default
- It has the following nine methods

1. **thread synchronisation** : wait, notify, notifyAll
2. **object identity** : hashCode, equals
3. **object management** : finalize, clone, getClass
4. **human readable representation** : toString

Some of the above methods are native, that means typically written in C or C++. Native methods are used to interface with system calls or libraries written in other programming languages

## Abstract Classes

- Can have fields and methods(static or not)
- Abstract methods do not have any implementations
- Static methods cannot be declared abstract
- You cannot create instances of abstract class
- It can extend any other class, abstract or not
- And it can contain constructors

## Interface

An interface is a special class that cannot be instantiated. It can contain
1. Public constants. You do not need to use public static final, that is automatically applied.
2. Abstract methods (abstract keyword is not required here)
3. Default methods with implementation. They can be overridden in sub classes.
4. Static methods with implementation

If modifiers are not specified, the method is assumed to be public abstract

An interface cannot contain
1. Fields
2. Constructors
3. Non public abstract methods

**Marker Interfaces**
- have an empty body
- They are used to provide important information to the JVM

- Interfaces support multiple inheritences
- An interface can only extend another interface

**Some differences between abstract and interface**

- An abstract class can have abstract and non-abstract instance methods while an interface can have abstract or default instance methods
- An abstract class can extend another abstract or regular class and an interface can only extend another interface
- An abstract class can extend only one class while an interface can extend any number of interfaces
- An abstract class can have final, non-final, static, non-static variables (regular fields) while an interface can only have static final variables
- An abstract class can provide an implementation of an interface but an interface cannot provide an implementation of an abstract class
- An abstract class can have a constructor and an interface cannot
- In an abstract class, the keyword abstract is mandatory to declare a method as an abstract one while in an interface this keyword is optional

## Anonymous Classes

Context variables
- It can capture variables of enclosing class(outer class)
- It can capture local variables which are either final or effectively final

Restrictions
- They cannot have static initialisers or interface declarations
- They cannot have static members except for constant variables(final static fields)
- They cannot have constructors

## Functional Interfaces

- Have a single abstract method(SAM)
- Can have static and default methods
- Can be implemented using anonymous classes or lambdas

**Closure**
- We can capture variables from the context where a lambda was declared which can later be used in the callback. This technique is known as a closure.
- The variable should be final or effectively final

In functional programming, a functions that accepts or returns another functions is known as a higher order function
List of common functional interfaces : https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html

** Pain of effectively final variables in java**
We can use only effectively final variables inside lamda's. There are three ways to get around this situation
1. Declare variables static
2. Use arrays instead
3. Use Atomic variables
Read more [here](https://dzone.com/articles/modifying-variable-inside-lambda) and [SO](https://stackoverflow.com/questions/30026824/modifying-local-variable-from-inside-lambda)


## Streams

- IntStream, LongStream and DoubleStream work with respective primitive types
- Stream<T> is generic. Works with various reference types


## Threading

**Monitors** 
- They are always present for an object
- They ensure that changes are visible across all threads once the critical section is over. You do not require volatile to provide visibility
- However, be wary while doing reads for shared variables. You might be tempted to make them unsynchronised. However, that makes them vulnerable to caching and hence reading stale values. Either make those shared variables volatile or make the read synchronised. Any of the above will ensure visbility of the shared variabled across the threads.

## Java Enterprise Edition (JEE)

Read these
1. [High Level Overview](https://stackoverflow.com/a/7295697/5131614)

## SOLID principles

1. **Single responsibilitly**
	Just do one thing only
2. **Open Close Prinicple ( OCP )** 
	Made once, but accepts anything falling in the criteria or is comparable. It should be extensible
3. **Liskov Substitution Principle**
	Any special function or object should be perfectly capable of performing all the functionality included in the general class. That is it should inherit all the functionality at the least, and then can add over it
4. **Interface Segregation**
	All functionalities should be separate for separate views. For example, a customer has a different view from a manager in a banking 
	application
5. **Dependency Injection**
	Providing inputs and other stuff is our responsibility. The object does not concern itself with that. 

## Singleton Design Pattern

There is a single global instance of a class.

Use cases :
1. Connection to databases
2. Universal logger for applications with the shared log file as the resource

We can use lazy singletons, wherein we instantiate the class only when get method is called. However, this is only for single thread environments.

## Observer Design Pattern

There are four components to this design pattern 
1. Observable subscribes observers, removes them, and notifies them about the changes
2. Concrete Observable implements Observable operations and describes some states
3. Observer subscribes to Observable and listens to its notification
4. Concrete Observer implements Observer interface and reacts on updating (Observable notification)

Usual use cases include
- when changing one component influences another component
- when subscriber publisher dependencies are present
- when you need to have low coupling between components

## Generic Programming

Naming convention
- T : type
- S, U, V : subsequent types
- E : element, used extensively in collections
- K : key
- V : value
- N : number

- The type argument in generics should always be a reference. Primitvie types are not allowed.
- Use var for automatic type inference
- You can achieve the same task as generics by using object type
- However, this shifts the checks to run time since we would now need to do an explicit cast on objects being returned from the class
- If there is a type mismatch, it would throw an error at runtime stalling the program if not handled.
- Generics by definition make these checks at compile time since there is no type casting involved
- You cannot use generic class type in a static method of that class

## Collections

- Collections cannot store primitive types


## Sets

Three major mutable implementations
1. HashSet : uses hash table. No guarantee for ordering. O(1) access to read operations.
2. TreeSet : provides ordering guarantee defined by a comparator. Extends sorted set interface. Works in log n, hence slower than hash set.
3. LinkedListSet : provides ordering with respect to insertion. As fast as hash set for reads but takes more memory

**Set Operations**
- Union : addAll
- Intersection : retainAll
- Difference : removeAll

## Stream Processing

Allows for transferring data between program and sources

**Broad Types**
1. Input streams
2. Output stream

1. Byte streams
2. Char streams


**Character Streams**
Reader is the super class extended by the following depending on the source of input stream 
- FileReader
- CharArrayReader
- StringReader

Some common methods of reader are
```java
// Reads a single character
int read()

// Reads characters into array
int read(char[] cbuf) 

// Reads characters into a portion of array
int read(char[] cbuf, int off, int len) 

// Reads characters into CharBuffer
int read(CharBuffer target) 
```

We receive -1 when we reach end of stream of an exception occurs. For array based reads, we receive the numbers of characters read


**Byte Stream**
InputStream is the super class exteneded by the following depending on the source of the input stream
- ByteArrayInputStream
- FileInputStream
- AudioInputStream

Some common methods of inputstream are
```java
// Reads a single byte
abstract int read() 

// Reads some number of bytes and stores them in byte array
int read(byte[] b) 

// Reads up to len bytes and stores them in byte array
int read(byte[] b, int off, int len) 

// Read all bytes
byte[] readAllBytes() 

// Reads the requested number of bytes and stores them in byte array
int readNBytes(byte[] b, int off, int len) 

// Reads the requested number of bytes
byte[] readNBytes(int len) 
```

readAllBytes stops at either end of file or end of stream, whereas readNBytes ends only at end of stream


**Buffered Streams**

```java

// For byte input streams:
BufferedInputStream(InputStream in)
BufferedInputStream(InputStream in, int size)

// For character input stream:
BufferedReader(Reader in)
BufferedReader(Reader in, int size)
```

## Handling Resource allocation

Taking care to close the streams in order to prevent leaks is important. You can use try with resource to automatically close the resources. 
Any resource that implements AutoCloseable can be used in try with resource. Check the [Official Documentation](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) for 
more information. 

## Escaping Characters

- For character escaping, we use \. The combination of backslash with a special character is known as **control sequence**
- List of control sequences in Java
    - \t : tab
    - \b : backspace
    - \n : newline
    - \r : carriage return
    - \f : form feed
    - \' : single quote
    - \" : double quote
    - \\ : backslash

You also use escape sequence to print Unicode characters. For example, 
```java
System.out.println("Following is a unicode character : \u00A9");
```
- Read more on this [here](https://codegym.cc/groups/posts/escaping-characters-java)

## Files

- For working in projects, you working directory is initialised as the root of the project

## Q/A

1. What is a JAR file ?
    - Just a zip file usually containing .class files. Check [this](https://stackoverflow.com/questions/12079230/what-exactly-does-a-jar-file-contain) for more details

2. Stuff about environment variables, classpath and related stuff
    - [In depth explanation](https://www.ntu.edu.sg/home/ehchua/programming/howto/environment_variables.html)
    - [Stack Overflow](https://stackoverflow.com/questions/2396493/what-is-a-classpath-and-how-do-i-set-it)

